<!doctype html>
<html class="theme-next use-motion theme-next-mist">
<head>
  

<meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>


<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />






  <link rel="stylesheet" type="text/css" href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5"/>




<link rel="stylesheet" type="text/css" href="/css/main.css?v=0.4.5.1"/>


    <meta name="description" content="前端开发,javascript,css3,html5,微信,博客" />



  <meta name="keywords" content="javascript,秘密花园," />



  <link rel="alternate" href="/atom.xml" title="Petitspois" type="application/atom+xml" />



  <link rel="shorticon icon" type="image/x-icon" href="/favicon.ico?v=0.4.5.1" />


<meta name="description" content="对象对象使用和属性JavaScript 中所有变量都是对象，除了两个例外 null 和 undefined。
123456false.toString(); // &apos;false&apos;[1, 2, 3].toString(); // &apos;1,2,3&apos;function Foo()&amp;#123;&amp;#125;Foo.bar = 1;Foo.bar; // 1
一个常见的误解是数字的字面值（literal）不是对象">
<meta property="og:type" content="article">
<meta property="og:title" content="Javascript 秘密花园">
<meta property="og:url" content="http://yoursite.com/2015/09/01/javascriptsecret/index.html">
<meta property="og:site_name" content="Petitspois">
<meta property="og:description" content="对象对象使用和属性JavaScript 中所有变量都是对象，除了两个例外 null 和 undefined。
123456false.toString(); // &apos;false&apos;[1, 2, 3].toString(); // &apos;1,2,3&apos;function Foo()&amp;#123;&amp;#125;Foo.bar = 1;Foo.bar; // 1
一个常见的误解是数字的字面值（literal）不是对象">
<meta property="og:updated_time" content="2015-09-01T08:49:05.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Javascript 秘密花园">
<meta name="twitter:description" content="对象对象使用和属性JavaScript 中所有变量都是对象，除了两个例外 null 和 undefined。
123456false.toString(); // &apos;false&apos;[1, 2, 3].toString(); // &apos;1,2,3&apos;function Foo()&amp;#123;&amp;#125;Foo.bar = 1;Foo.bar; // 1
一个常见的误解是数字的字面值（literal）不是对象">


<script type="text/javascript" id="hexo.configuration">
  var CONFIG = {
    scheme: 'Mist',
    sidebar: 'hide'
  };
</script>

  <title> Javascript 秘密花园 | Petitspois </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  <!--[if lte IE 8]>
  <div style=' clear: both; height: 59px; padding:0 0 0 15px; position: relative;margin:0 auto;'>
    <a href="http://windows.microsoft.com/en-US/internet-explorer/products/ie/home?ocid=ie6_countdown_bannercode">
      <img src="http://7u2nvr.com1.z0.glb.clouddn.com/picouterie.jpg" border="0" height="42" width="820"
           alt="You are using an outdated browser. For a faster, safer browsing experience, upgrade for free today or use other browser ,like chrome firefox safari."
           style='margin-left:auto;margin-right:auto;display: block;'/>
    </a>
  </div>
<![endif]-->
  

  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "//hm.baidu.com/hm.js?1275cad33c2bc4ebb08a1271d3309499";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>



  <div class="container one-column page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><h1 class="site-meta">
  <span class="logo-line-before"><i></i></span>
  <a href="/" class="brand" rel="start">
      <span class="logo">
        <i class="icon-next-logo"></i>
      </span>
      <span class="site-title">Petitspois</span>
  </a>
  <span class="logo-line-after"><i></i></span>
</h1>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu menu-left">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            <i class="menu-item-icon icon-next-home"></i> <br />
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            <i class="menu-item-icon icon-next-about"></i> <br />
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            <i class="menu-item-icon icon-next-archives"></i> <br />
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            <i class="menu-item-icon icon-next-tags"></i> <br />
            标签
          </a>
        </li>
      

      
      
    </ul>
  

  
    <div class="site-search">
      
  
  <form class="site-search-form">
    <input type="text" id="st-search-input" class="st-search-input st-default-search-input" />
  </form>


<script type="text/javascript">
  (function(w,d,t,u,n,s,e){w['SwiftypeObject']=n;w[n]=w[n]||function(){
    (w[n].q=w[n].q||[]).push(arguments);};s=d.createElement(t);
    e=d.getElementsByTagName(t)[0];s.async=1;s.src=u;e.parentNode.insertBefore(s,e);
  })(window,document,'script','//s.swiftypecdn.com/install/v2/st.js','_st');

  _st('install', 'Xb82XF_ud8PSLnyzd37Y','2.0.0');
</script>



    </div>
  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div id="content" class="content"> 

  <div id="posts" class="posts-expand">
    

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">

      
      
        <h1 class="post-title" itemprop="name headline">
          
          
            
              Javascript 秘密花园
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于
          <time itemprop="dateCreated" datetime="2015-09-01T16:49:05+08:00" content="2015-09-01">
            2015-09-01
          </time>
        </span>

        

        
          
            <span class="post-comments-count">
              &nbsp; | &nbsp;
              <a href="/2015/09/01/javascriptsecret/#comments" itemprop="discussionUrl">
                <span class="post-comments-count ds-thread-count" data-thread-key="2015/09/01/javascriptsecret/" itemprop="commentsCount"></span>
              </a>
            </span>
          
        
      </div>
    </header>

    <div class="post-body">

      
      

      
        <span itemprop="articleBody"><h1 id="对象">对象</h1><h2 id="对象使用和属性">对象使用和属性</h2><p>JavaScript 中所有变量都是对象，除了两个例外 <code>null</code> 和 <code>undefined</code>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="literal">false</span>.toString(); <span class="comment">// 'false'</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].toString(); <span class="comment">// '1,2,3'</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Foo</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">Foo.bar = <span class="number">1</span>;</span><br><span class="line">Foo.bar; <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>
<p>一个常见的误解是数字的字面值（literal）不是对象。这是因为 JavaScript 解析器的一个错误， 它试图将点操作符解析为浮点数字面值的一部分。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2.</span>toString(); <span class="comment">// 出错：SyntaxError</span></span><br></pre></td></tr></table></figure>
<a id="more"></a>
<p>有很多变通方法可以让数字的字面值看起来像对象。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2.</span>.toString(); <span class="comment">// 第二个点号可以正常解析</span></span><br><span class="line"><span class="number">2</span> .toString(); <span class="comment">// 注意点号前面的空格</span></span><br><span class="line">(<span class="number">2</span>).toString(); <span class="comment">// 2先被计算</span></span><br></pre></td></tr></table></figure>
<h3 id="对象作为数据类型">对象作为数据类型</h3><p>JavaScript 的对象可以作为哈希表使用，主要用来保存命名的键与值的对应关系。</p>
<p>使用对象的字面语法 - <code>{}</code> - 可以创建一个简单对象。这个新创建的对象从 <code>Object.prototype</code> 继承下面，没有任何自定义属性。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = &#123;&#125;; <span class="comment">// 一个空对象</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 一个新对象，拥有一个值为12的自定义属性'test'</span></span><br><span class="line"><span class="keyword">var</span> bar = &#123;test: <span class="number">12</span>&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="访问属性">访问属性</h3><p>有两种方式来访问对象的属性，点操作符或者中括号操作符。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = &#123;name: <span class="string">'kitten'</span>&#125;</span><br><span class="line">foo.name; <span class="comment">// kitten</span></span><br><span class="line">foo[<span class="string">'name'</span>]; <span class="comment">// kitten</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> get = <span class="string">'name'</span>;</span><br><span class="line">foo[get]; <span class="comment">// kitten</span></span><br><span class="line"></span><br><span class="line">foo<span class="number">.1234</span>; <span class="comment">// SyntaxError</span></span><br><span class="line">foo[<span class="string">'1234'</span>]; <span class="comment">// works</span></span><br></pre></td></tr></table></figure>
<p>两种语法是等价的，但是中括号操作符在下面两种情况下依然有效</p>
<ul>
<li>动态设置属性</li>
<li>属性名不是一个有效的变量名（译者注：比如属性名中包含空格，或者属性名是 JS 的关键词）</li>
</ul>
<h3 id="删除属性">删除属性</h3><p>删除属性的唯一方法是使用 <code>delete</code> 操作符；设置属性为 <code>undefined</code> 或者 <code>null</code> 并不能真正的删除属性， 而仅仅是移除了属性和值的关联。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    bar: <span class="number">1</span>,</span><br><span class="line">    foo: <span class="number">2</span>,</span><br><span class="line">    baz: <span class="number">3</span></span><br><span class="line">&#125;;</span><br><span class="line">obj.bar = <span class="literal">undefined</span>;</span><br><span class="line">obj.foo = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">delete</span> obj.baz;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i <span class="keyword">in</span> obj) &#123;</span><br><span class="line">    <span class="keyword">if</span> (obj.hasOwnProperty(i)) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(i, <span class="string">''</span> + obj[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的输出结果有 <code>bar</code> <code>undefined</code> 和 <code>foo null</code> - 只有 <code>baz</code> 被真正的删除了，所以从输出结果中消失。</p>
<h3 id="属性名的语法">属性名的语法</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> test = &#123;</span><br><span class="line">    <span class="string">'case'</span>: <span class="string">'I am a keyword so I must be notated as a string'</span>,</span><br><span class="line">    <span class="keyword">delete</span>: <span class="string">'I am a keyword too so me'</span> <span class="comment">// 出错：SyntaxError</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>对象的属性名可以使用字符串或者普通字符声明。但是由于 JavaScript 解析器的另一个错误设计， 上面的第二种声明方式在 ECMAScript 5 之前会抛出 <code>SyntaxError</code> 的错误。</p>
<p>这个错误的原因是 <code>delete</code> 是 JavaScript 语言的一个关键词；因此为了在更低版本的 JavaScript 引擎下也能正常运行， 必须使用字符串字面值声明方式。</p>
<h2 id="原型">原型</h2><p>JavaScript 不包含传统的类继承模型，而是使用 prototype 原型模型。</p>
<p>虽然这经常被当作是 JavaScript 的缺点被提及，其实基于原型的继承模型比传统的类继承还要强大。 实现传统的类继承模型是很简单，但是实现 JavaScript 中的原型继承则要困难的多。 (It is for example fairly trivial to build a classic model on top of it, while the other way around is a far more difficult task.)</p>
<p>由于 JavaScript 是唯一一个被广泛使用的基于原型继承的语言，所以理解两种继承模式的差异是需要一定时间的。</p>
<p>第一个不同之处在于 JavaScript 使用原型链的继承方式。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.value = <span class="number">42</span>;</span><br><span class="line">&#125;</span><br><span class="line">Foo.prototype = &#123;</span><br><span class="line">    method: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Bar</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置Bar的prototype属性为Foo的实例对象</span></span><br><span class="line">Bar.prototype = <span class="keyword">new</span> Foo();</span><br><span class="line">Bar.prototype.foo = <span class="string">'Hello World'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 修正Bar.prototype.constructor为Bar本身</span></span><br><span class="line">Bar.prototype.constructor = Bar;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> test = <span class="keyword">new</span> Bar() <span class="comment">// 创建Bar的一个新实例</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 原型链</span></span><br><span class="line">test [Bar的实例]</span><br><span class="line">    Bar.prototype [Foo的实例] </span><br><span class="line">        &#123; foo: <span class="string">'Hello World'</span> &#125;</span><br><span class="line">        Foo.prototype</span><br><span class="line">            &#123;method: ...&#125;;</span><br><span class="line">            <span class="built_in">Object</span>.prototype</span><br><span class="line">                &#123;toString: ... <span class="comment">/* etc. */</span>&#125;;</span><br></pre></td></tr></table></figure>
<p>上面的例子中，<code>test</code> 对象从 <code>Bar.prototype</code> 和 <code>Foo.prototype</code> 继承下来；因此， 它能访问 Foo 的原型方法 method。同时，它也能够访问那个定义在原型上的 Foo 实例属性 value。 需要注意的是 <code>new Bar()</code> 不会创造出一个新的 Foo 实例，而是 重复使用它原型上的那个实例；因此，所有的 Bar 实例都会共享相同的 value 属性。</p>
<h3 id="属性查找">属性查找</h3><p>当查找一个对象的属性时，JavaScript 会向上遍历原型链，直到找到给定名称的属性为止。</p>
<p>到查找到达原型链的顶部 - 也就是 <code>Object.prototype</code> - 但是仍然没有找到指定的属性，就会返回 undefined。</p>
<h3 id="原型属性">原型属性</h3><p>当原型属性用来创建原型链时，可以把任何类型的值赋给它（prototype）。 然而将原子类型赋给 prototype 的操作将会被忽略。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Foo</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">Foo.prototype = <span class="number">1</span>; <span class="comment">// 无效</span></span><br></pre></td></tr></table></figure>
<p>而将对象赋值给 prototype，正如上面的例子所示，将会动态的创建原型链。</p>
<h3 id="性能">性能</h3><p>如果一个属性在原型链的上端，则对于查找时间将带来不利影响。特别的，试图获取一个不存在的属性将会遍历整个原型链。</p>
<p>并且，当使用 <code>for in</code> 循环遍历对象的属性时，原型链上的所有属性都将被访问。</p>
<h3 id="扩展内置类型的原型">扩展内置类型的原型</h3><p>一个错误特性被经常使用，那就是扩展 <code>Object.prototype</code> 或者其他内置类型的原型对象。</p>
<p>这种技术被称之为 monkey patching 并且会破坏封装。虽然它被广泛的应用到一些 JavaScript 类库中比如 Prototype, 但是我仍然不认为为内置类型添加一些非标准的函数是个好主意。</p>
<p>扩展内置类型的唯一理由是为了和新的 JavaScript 保持一致，比如 <code>Array.forEach</code>。</p>
<h3 id="总结">总结</h3><p>在写复杂的 JavaScript 应用之前，充分理解原型链继承的工作方式是每个 JavaScript 程序员必修的功课。 要提防原型链过长带来的性能问题，并知道如何通过缩短原型链来提高性能。 更进一步，绝对不要扩展内置类型的原型，除非是为了和新的 JavaScript 引擎兼容。</p>
<h2 id="hasOwnProperty_函数">hasOwnProperty 函数</h2><p>为了判断一个对象是否包含自定义属性而不是原型链上的属性， 我们需要使用继承自 <code>Object.prototype</code> 的 <code>hasOwnProperty</code> 方法。</p>
<p>注意: 通过判断一个属性是否 undefined 是不够的。 因为一个属性可能确实存在，只不过它的值被设置为 <code>undefined</code>。<br><code>hasOwnProperty</code> 是 JavaScript 中唯一一个处理属性但是不查找原型链的函数。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 修改Object.prototype</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.bar = <span class="number">1</span>; </span><br><span class="line"><span class="keyword">var</span> foo = &#123;goo: <span class="literal">undefined</span>&#125;;</span><br><span class="line"></span><br><span class="line">foo.bar; <span class="comment">// 1</span></span><br><span class="line"><span class="string">'bar'</span> <span class="keyword">in</span> foo; <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">foo.hasOwnProperty(<span class="string">'bar'</span>); <span class="comment">// false</span></span><br><span class="line">foo.hasOwnProperty(<span class="string">'goo'</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>只有 <code>hasOwnProperty</code> 可以给出正确和期望的结果，这在遍历对象的属性时会很有用。 没有其它方法可以用来排除原型链上的属性，而不是定义在对象自身上的属性。</p>
<h3 id="hasOwnProperty_作为属性">hasOwnProperty 作为属性</h3><p>JavaScript 不会保护 <code>hasOwnProperty</code> 被非法占用，因此如果一个对象碰巧存在这个属性， 就需要使用外部的 <code>hasOwnProperty</code> 函数来获取正确的结果。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = &#123;</span><br><span class="line">    hasOwnProperty: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;,</span><br><span class="line">    bar: <span class="string">'Here be dragons'</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">foo.hasOwnProperty(<span class="string">'bar'</span>); <span class="comment">// 总是返回 false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用其它对象的 hasOwnProperty，并将其上下文设置为foo</span></span><br><span class="line">(&#123;&#125;).hasOwnProperty.call(foo, <span class="string">'bar'</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<h3 id="结论">结论</h3><p>当检查对象上某个属性是否存在时，<code>hasOwnProperty</code> 是唯一可用的方法。 同时在使用 <code>for in loop</code> 遍历对象时，推荐总是使用 <code>hasOwnProperty</code> 方法， 这将会避免原型对象扩展带来的干扰。</p>
<h2 id="for_in_循环">for in 循环</h2><p>和 in 操作符一样，for in 循环同样在查找对象属性时遍历原型链上的所有属性。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 修改 Object.prototype</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.bar = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> foo = &#123;moo: <span class="number">2</span>&#125;;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i <span class="keyword">in</span> foo) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i); <span class="comment">// 输出两个属性：bar 和 moo</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于不可能改变 for in 自身的行为，因此有必要过滤出那些不希望出现在循环体中的属性， 这可以通过 <code>Object.prototype</code> 原型上的 hasOwnProperty 函数来完成。</p>
<h3 id="使用_hasOwnProperty_过滤">使用 hasOwnProperty 过滤</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// foo 变量是上例中的</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i <span class="keyword">in</span> foo) &#123;</span><br><span class="line">    <span class="keyword">if</span> (foo.hasOwnProperty(i)) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个版本的代码是唯一正确的写法。由于我们使用了 hasOwnProperty，所以这次只输出 moo。 如果不使用 hasOwnProperty，则这段代码在原生对象原型（比如 Object.prototype）被扩展时可能会出错。</p>
<p>一个广泛使用的类库 Prototype 就扩展了原生的 JavaScript 对象。 因此，当这个类库被包含在页面中时，不使用 hasOwnProperty 过滤的 for in 循环难免会出问题。</p>
<h3 id="总结-1">总结</h3><p>推荐总是使用 hasOwnProperty。不要对代码运行的环境做任何假设，不要假设原生对象是否已经被扩展了。</p>
<h1 id="函数_f(x)">函数 f(x)</h1><h2 id="函数声明与表达式">函数声明与表达式</h2><p>函数是JavaScript中的一等对象，这意味着可以把函数像其它值一样传递。 一个常见的用法是把匿名函数作为回调函数传递到异步函数中。</p>
<h3 id="函数声明">函数声明</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;&#125;</span><br></pre></td></tr></table></figure>
<p>上面的方法会在执行前被 解析(hoisted)，因此它存在于当前上下文的任意一个地方， 即使在函数定义体的上面被调用也是对的。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">foo(); <span class="comment">// 正常运行，因为foo在代码运行前已经被创建</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;&#125;</span><br></pre></td></tr></table></figure>
<h3 id="函数赋值表达式">函数赋值表达式</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br></pre></td></tr></table></figure>
<p>这个例子把一个匿名的函数赋值给变量 foo。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">foo; <span class="comment">// 'undefined'</span></span><br><span class="line">foo(); <span class="comment">// 出错：TypeError</span></span><br><span class="line"><span class="keyword">var</span> foo = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br></pre></td></tr></table></figure>
<p>由于 var 定义了一个声明语句，对变量 foo 的解析是在代码运行之前，因此 foo 变量在代码运行时已经被定义过了。</p>
<p>但是由于赋值语句只在运行时执行，因此在相应代码执行之前， foo 的值缺省为 undefined。</p>
<h3 id="命名函数的赋值表达式">命名函数的赋值表达式</h3><p>另外一个特殊的情况是将命名函数赋值给一个变量。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = <span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    bar(); <span class="comment">// 正常运行</span></span><br><span class="line">&#125;</span><br><span class="line">bar(); <span class="comment">// 出错：ReferenceError</span></span><br></pre></td></tr></table></figure>
<p>bar 函数声明外是不可见的，这是因为我们已经把函数赋值给了 foo； 然而在 bar 内部依然可见。这是由于 JavaScript 的 命名处理 所致， 函数名在函数内总是可见的。</p>
<h2 id="this_的工作原理">this 的工作原理</h2><p>JavaScript 有一套完全不同于其它语言的对 this 的处理机制。 在五种不同的情况下 ，this 指向的各不相同。</p>
<h3 id="全局范围内">全局范围内</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>;</span><br></pre></td></tr></table></figure>
<p>当在全部范围内使用 this，它将会指向全局对象。</p>
<h3 id="函数调用">函数调用</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">foo();</span><br></pre></td></tr></table></figure>
<p>这里 this 也会指向全局对象。</p>
<h3 id="方法调用">方法调用</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">test.foo();</span><br></pre></td></tr></table></figure>
<p>这个例子中，this 指向 test 对象。</p>
<h3 id="调用构造函数">调用构造函数</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> foo();</span><br></pre></td></tr></table></figure>
<p>如果函数倾向于和 new 关键词一块使用，则我们称这个函数是 构造函数。 在函数内部，this 指向新创建的对象。</p>
<h3 id="显式的设置_this">显式的设置 this</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">a, b, c</span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> bar = &#123;&#125;;</span><br><span class="line">foo.apply(bar, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]); <span class="comment">// 数组将会被扩展，如下所示</span></span><br><span class="line">foo.call(bar, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>); <span class="comment">// 传递到foo的参数是：a = 1, b = 2, c = 3</span></span><br></pre></td></tr></table></figure>
<p>当使用 Function.prototype 上的 call 或者 apply 方法时，函数内的 this 将会被 显式设置为函数调用的第一个参数。</p>
<p>因此函数调用的规则在上例中已经不适用了，在foo 函数内 this 被设置成了 bar。</p>
<h3 id="常见误解">常见误解</h3><p>尽管大部分的情况都说的过去，不过第一个规则（译者注：这里指的应该是第二个规则，也就是直接调用函数时，this 指向全局对象） 被认为是JavaScript语言另一个错误设计的地方，因为它从来就没有实际的用途。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Foo.method = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="comment">// this 将会被设置为全局对象（译者注：浏览器环境中也就是 window 对象）</span></span><br><span class="line">    &#125;</span><br><span class="line">    test();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一个常见的误解是 test 中的 this 将会指向 Foo 对象，实际上不是这样子的。</p>
<p>为了在 test 中获取对 Foo 对象的引用，我们需要在 method 函数内部创建一个局部变量指向 Foo 对象。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Foo.method = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> that = <span class="keyword">this</span>;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 使用 that 来指向 Foo 对象</span></span><br><span class="line">    &#125;</span><br><span class="line">    test();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>that 只是我们随意起的名字，不过这个名字被广泛的用来指向外部的 this 对象。 在 闭包 一节，我们可以看到 that 可以作为参数传递。</p>
<h3 id="方法的赋值表达式">方法的赋值表达式</h3><p>另一个看起来奇怪的地方是函数别名，也就是将一个方法赋值给一个变量。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> test = someObject.methodTest;</span><br><span class="line">test();</span><br></pre></td></tr></table></figure>
<p>上例中，test 就像一个普通的函数被调用；因此，函数内的 this 将不再被指向到 someObject 对象。</p>
<p>虽然 this 的晚绑定特性似乎并不友好，但这确实是基于原型继承赖以生存的土壤。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Foo</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">Foo.prototype.method = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Bar</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">Bar.prototype = Foo.prototype;</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Bar().method();</span><br></pre></td></tr></table></figure>
<p>当 method 被调用时，this 将会指向 Bar 的实例对象。</p>
<h2 id="闭包和引用">闭包和引用</h2><p>闭包是 JavaScript 一个非常重要的特性，这意味着当前作用域总是能够访问外部作用域中的变量。 因为 函数 是 JavaScript 中唯一拥有自身作用域的结构，因此闭包的创建依赖于函数。</p>
<h3 id="模拟私有变量">模拟私有变量</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Counter</span>(<span class="params">start</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> count = start;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        increment: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;,</span><br><span class="line"></span><br><span class="line">        get: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> count;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> foo = Counter(<span class="number">4</span>);</span><br><span class="line">foo.increment();</span><br><span class="line">foo.get(); <span class="comment">// 5</span></span><br></pre></td></tr></table></figure>
<p>这里，Counter 函数返回两个闭包，函数 increment 和函数 get。 这两个函数都维持着 对外部作用域 Counter 的引用，因此总可以访问此作用域内定义的变量 count.</p>
<h3 id="为什么不可以在外部访问私有变量">为什么不可以在外部访问私有变量</h3><p>因为 JavaScript 中不可以对作用域进行引用或赋值，因此没有办法在外部访问 count 变量。 唯一的途径就是通过那两个闭包。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = <span class="keyword">new</span> Counter(<span class="number">4</span>);</span><br><span class="line">foo.hack = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    count = <span class="number">1337</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>上面的代码不会改变定义在 Counter 作用域中的 count 变量的值，因为 foo.hack 没有 定义在那个作用域内。它将会创建或者覆盖全局变量 count。</p>
<h3 id="循环中的闭包">循环中的闭包</h3><p>一个常见的错误出现在循环中使用闭包，假设我们需要在每次循环中调用循环序号</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(i);  </span><br><span class="line">    &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的代码不会输出数字 0 到 9，而是会输出数字 10 十次。</p>
<p>当 console.log 被调用的时候，匿名函数保持对外部变量 i 的引用，此时 for循环已经结束， i 的值被修改成了 10.</p>
<p>为了得到想要的结果，需要在每次循环中创建变量 i 的拷贝。</p>
<h3 id="避免引用错误">避免引用错误</h3><p>为了正确的获得循环序号，最好使用 匿名包装器（译者注：其实就是我们通常说的自执行匿名函数）。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    (<span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">        setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(e);  </span><br><span class="line">        &#125;, <span class="number">1000</span>);</span><br><span class="line">    &#125;)(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>外部的匿名函数会立即执行，并把 i 作为它的参数，此时函数内 e 变量就拥有了 i 的一个拷贝。</p>
<p>当传递给 setTimeout 的匿名函数执行时，它就拥有了对 e 的引用，而这个值是不会被循环改变的。</p>
<p>有另一个方法完成同样的工作，那就是从匿名包装器中返回一个函数。这和上面的代码效果一样。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    setTimeout((<span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)(i), <span class="number">1000</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="arguments_对象">arguments 对象</h2><p>JavaScript 中每个函数内都能访问一个特别变量 arguments。这个变量维护着所有传递到这个函数中的参数列表。</p>
<p>注意: 由于 arguments 已经被定义为函数内的一个变量。 因此通过 var 关键字定义 arguments 或者将 arguments 声明为一个形式参数， 都将导致原生的 arguments 不会被创建。<br>arguments 变量不是一个数组（Array）。 尽管在语法上它有数组相关的属性 length，但它不从 Array.prototype 继承，实际上它是一个对象（Object）。</p>
<p>因此，无法对 arguments 变量使用标准的数组方法，比如 push, pop 或者 slice。 虽然使用 for 循环遍历也是可以的，但是为了更好的使用数组方法，最好把它转化为一个真正的数组。</p>
<h3 id="转化为数组">转化为数组</h3><p>下面的代码将会创建一个新的数组，包含所有 arguments 对象中的元素。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>);</span><br></pre></td></tr></table></figure>
<p>这个转化比较慢，在性能不好的代码中不推荐这种做法。</p>
<h3 id="传递参数">传递参数</h3><p>下面是将参数从一个函数传递到另一个函数的推荐做法。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    bar.apply(<span class="literal">null</span>, <span class="built_in">arguments</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params">a, b, c</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 干活</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>另一个技巧是同时使用 call 和 apply，创建一个快速的解绑定包装器。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Foo</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">Foo.prototype.method = <span class="function"><span class="keyword">function</span>(<span class="params">a, b, c</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>, a, b, c);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个解绑定的 "method"</span></span><br><span class="line"><span class="comment">// 输入参数为: this, arg1, arg2...argN</span></span><br><span class="line">Foo.method = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 结果: Foo.prototype.method.call(this, arg1, arg2... argN)</span></span><br><span class="line">    <span class="built_in">Function</span>.call.apply(Foo.prototype.method, <span class="built_in">arguments</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>译者注：上面的 Foo.method 函数和下面代码的效果是一样的:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Foo.method = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> args = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>);</span><br><span class="line">    Foo.prototype.method.apply(args[<span class="number">0</span>], args.slice(<span class="number">1</span>));</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="自动更新">自动更新</h3><p>arguments 对象为其内部属性以及函数形式参数创建 getter 和 setter 方法。</p>
<p>因此，改变形参的值会影响到 arguments 对象的值，反之亦然。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">a, b, c</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">arguments</span>[<span class="number">0</span>] = <span class="number">2</span>;</span><br><span class="line">    a; <span class="comment">// 2                                                           </span></span><br><span class="line"></span><br><span class="line">    b = <span class="number">4</span>;</span><br><span class="line">    <span class="built_in">arguments</span>[<span class="number">1</span>]; <span class="comment">// 4</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> d = c;</span><br><span class="line">    d = <span class="number">9</span>;</span><br><span class="line">    c; <span class="comment">// 3</span></span><br><span class="line">&#125;</span><br><span class="line">foo(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br></pre></td></tr></table></figure>
<h3 id="性能真相">性能真相</h3><p>不管它是否有被使用，arguments 对象总会被创建，除了两个特殊情况 - 作为局部变量声明和作为形式参数。</p>
<p>arguments 的 getters 和 setters 方法总会被创建；因此使用 arguments 对性能不会有什么影响。 除非是需要对 arguments 对象的属性进行多次访问。</p>
<p>ES5 提示: 这些 getters 和 setters 在严格模式下（strict mode）不会被创建。<br>译者注：在 MDC 中对 strict mode 模式下 arguments 的描述有助于我们的理解，请看下面代码：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 阐述在 ES5 的严格模式下 `arguments` 的特性</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">a</span>) </span>&#123;</span><br><span class="line"><span class="pi">  "use strict"</span>;</span><br><span class="line">  a = <span class="number">42</span>;</span><br><span class="line">  <span class="keyword">return</span> [a, <span class="built_in">arguments</span>[<span class="number">0</span>]];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> pair = f(<span class="number">17</span>);</span><br><span class="line"><span class="built_in">console</span>.assert(pair[<span class="number">0</span>] === <span class="number">42</span>);</span><br><span class="line"><span class="built_in">console</span>.assert(pair[<span class="number">1</span>] === <span class="number">17</span>);</span><br></pre></td></tr></table></figure>
<p>然而，的确有一种情况会显著的影响现代 JavaScript 引擎的性能。这就是使用 arguments.callee。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">arguments</span>.callee; <span class="comment">// do something with this function object</span></span><br><span class="line">    <span class="built_in">arguments</span>.callee.caller; <span class="comment">// and the calling function object</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bigLoop</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">100000</span>; i++) &#123;</span><br><span class="line">        foo(); <span class="comment">// Would normally be inlined...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码中，foo 不再是一个单纯的内联函数 inlining（译者注：这里指的是解析器可以做内联处理）， 因为它需要知道它自己和它的调用者。 这不仅抵消了内联函数带来的性能提升，而且破坏了封装，因此现在函数可能要依赖于特定的上下文。</p>
<p>因此强烈建议大家不要使用 arguments.callee 和它的属性。</p>
<h2 id="构造函数">构造函数</h2><p>JavaScript 中的构造函数和其它语言中的构造函数是不同的。 通过 new 关键字方式调用的函数都被认为是构造函数。</p>
<p>在构造函数内部 - 也就是被调用的函数内 - this 指向新创建的对象 Object。 这个新创建的对象的 prototype 被指向到构造函数的 prototype。</p>
<p>如果被调用的函数没有显式的 return 表达式，则隐式的会返回 this 对象 - 也就是新创建的对象。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.bla = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Foo.prototype.test = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.bla);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> test = <span class="keyword">new</span> Foo();</span><br></pre></td></tr></table></figure>
<p>上面代码把 Foo 作为构造函数调用，并设置新创建对象的 prototype 为 Foo.prototype。</p>
<p>显式的 return 表达式将会影响返回结果，但仅限于返回的是一个对象。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">new</span> Bar(); <span class="comment">// 返回新创建的对象</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.value = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        foo: <span class="number">1</span></span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">new</span> Test(); <span class="comment">// 返回的对象</span></span><br></pre></td></tr></table></figure>
<p>译者注：new Bar() 返回的是新创建的对象，而不是数字的字面值 2。 因此 new Bar().constructor === Bar，但是如果返回的是数字对象，结果就不同了，如下所示</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Number</span>(<span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">new</span> Bar().constructor === <span class="built_in">Number</span></span><br></pre></td></tr></table></figure>
<p>译者注：这里得到的 new Test()是函数返回的对象，而不是通过new关键字新创建的对象，因此：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">new</span> Test()).value === <span class="literal">undefined</span></span><br><span class="line">(<span class="keyword">new</span> Test()).foo === <span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>如果 new 被遗漏了，则函数不会返回新创建的对象。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.bla = <span class="number">1</span>; <span class="comment">// 获取设置全局参数</span></span><br><span class="line">&#125;</span><br><span class="line">Foo(); <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>
<p>虽然上例在有些情况下也能正常运行，但是由于 JavaScript 中 this 的工作原理， 这里的 this 指向全局对象。</p>
<h3 id="工厂模式">工厂模式</h3><p>为了不使用 new 关键字，构造函数必须显式的返回一个值。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> value = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        method: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">Bar.prototype = &#123;</span><br><span class="line">    foo: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Bar();</span><br><span class="line">Bar();</span><br></pre></td></tr></table></figure>
<p>上面两种对 Bar 函数的调用返回的值完全相同，一个新创建的拥有 method 属性的对象被返回， 其实这里创建了一个闭包。</p>
<p>还需要注意， new Bar() 并不会改变返回对象的原型（译者注：也就是返回对象的原型不会指向 Bar.prototype）。 因为构造函数的原型会被指向到刚刚创建的新对象，而这里的 Bar 没有把这个新对象返回（译者注：而是返回了一个包含 method 属性的自定义对象）。</p>
<p>在上面的例子中，使用或者不使用 new 关键字没有功能性的区别。</p>
<p>译者注：上面两种方式创建的对象不能访问 Bar 原型链上的属性，如下所示：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> bar1 = <span class="keyword">new</span> Bar();</span><br><span class="line"><span class="keyword">typeof</span>(bar1.method); <span class="comment">// "function"</span></span><br><span class="line"><span class="keyword">typeof</span>(bar1.foo); <span class="comment">// "undefined"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> bar2 = Bar();</span><br><span class="line"><span class="keyword">typeof</span>(bar2.method); <span class="comment">// "function"</span></span><br><span class="line"><span class="keyword">typeof</span>(bar2.foo); <span class="comment">// "undefined"</span></span><br></pre></td></tr></table></figure>
<h3 id="通过工厂模式创建新对象">通过工厂模式创建新对象</h3><p>我们常听到的一条忠告是不要使用 new 关键字来调用函数，因为如果忘记使用它就会导致错误。</p>
<p>为了创建新对象，我们可以创建一个工厂方法，并且在方法内构造一个新对象。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> obj = &#123;&#125;;</span><br><span class="line">    obj.value = <span class="string">'blub'</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> private = <span class="number">2</span>;</span><br><span class="line">    obj.someMethod = <span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    obj.getPrivate = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> private;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>虽然上面的方式比起 new 的调用方式不容易出错，并且可以充分利用私有变量带来的便利， 但是随之而来的是一些不好的地方。</p>
<ol>
<li>会占用更多的内存，因为新创建的对象不能共享原型上的方法。</li>
<li>为了实现继承，工厂方法需要从另外一个对象拷贝所有属性，或者把一个对象作为新创建对象的原型。</li>
<li>放弃原型链仅仅是因为防止遗漏 new 带来的问题，这似乎和语言本身的思想相违背。</li>
</ol>
<h3 id="总结-2">总结</h3><p>虽然遗漏 new 关键字可能会导致问题，但这并不是放弃使用原型链的借口。 最终使用哪种方式取决于应用程序的需求，选择一种代码书写风格并坚持下去才是最重要的。</p>
<h2 id="作用域与命名空间">作用域与命名空间</h2><p>尽管 JavaScript 支持一对花括号创建的代码段，但是并不支持块级作用域； 而仅仅支持 函数作用域。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123; <span class="comment">// 一个作用域</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123; <span class="comment">// 不是一个作用域</span></span><br><span class="line">        <span class="comment">// count</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">console</span>.log(i); <span class="comment">// 10</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>译者注：如果 return 对象的左括号和 return 不在一行上就会出错。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 译者注：下面输出 undefined</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> </span><br><span class="line">        a + b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(add(<span class="number">1</span>, <span class="number">2</span>));</span><br></pre></td></tr></table></figure>
<p>JavaScript 中没有显式的命名空间定义，这就意味着所有对象都定义在一个全局共享的命名空间下面。</p>
<p>每次引用一个变量，JavaScript 会向上遍历整个作用域直到找到这个变量为止。 如果到达全局作用域但是这个变量仍未找到，则会抛出 ReferenceError 异常。</p>
<h3 id="隐式的全局变量">隐式的全局变量</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 脚本 A</span></span><br><span class="line">foo = <span class="string">'42'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 脚本 B</span></span><br><span class="line"><span class="keyword">var</span> foo = <span class="string">'42'</span></span><br></pre></td></tr></table></figure>
<p>上面两段脚本效果不同。脚本 A 在全局作用域内定义了变量 foo，而脚本 B 在当前作用域内定义变量 foo。</p>
<p>再次强调，上面的效果完全不同，不使用 var 声明变量将会导致隐式的全局变量产生。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 全局作用域</span></span><br><span class="line"><span class="keyword">var</span> foo = <span class="number">42</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 局部作用域</span></span><br><span class="line">    foo = <span class="number">21</span>;</span><br><span class="line">&#125;</span><br><span class="line">test();</span><br><span class="line">foo; <span class="comment">// 21</span></span><br></pre></td></tr></table></figure>
<p>在函数 test 内不使用 var 关键字声明 foo 变量将会覆盖外部的同名变量。 起初这看起来并不是大问题，但是当有成千上万行代码时，不使用 var 声明变量将会带来难以跟踪的 BUG。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 全局作用域</span></span><br><span class="line"><span class="keyword">var</span> items = [<span class="comment">/* 数组 */</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    subLoop();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">subLoop</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// subLoop 函数作用域</span></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123; <span class="comment">// 没有使用 var 声明变量</span></span><br><span class="line">        <span class="comment">// 干活</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>外部循环在第一次调用 subLoop 之后就会终止，因为 subLoop 覆盖了全局变量 i。 在第二个 for 循环中使用 var 声明变量可以避免这种错误。 声明变量时绝对不要遗漏 var 关键字，除非这就是期望的影响外部作用域的行为。</p>
<h3 id="局部变量">局部变量</h3><p>JavaScript 中局部变量只可能通过两种方式声明，一个是作为函数参数，另一个是通过 var 关键字声明。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 全局变量</span></span><br><span class="line"><span class="keyword">var</span> foo = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">var</span> bar = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">var</span> i = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params">i</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 函数 test 内的局部作用域</span></span><br><span class="line">    i = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> foo = <span class="number">3</span>;</span><br><span class="line">    bar = <span class="number">4</span>;</span><br><span class="line">&#125;</span><br><span class="line">test(<span class="number">10</span>);</span><br></pre></td></tr></table></figure>
<p>foo 和 i 是函数 test 内的局部变量，而对 bar 的赋值将会覆盖全局作用域内的同名变量。</p>
<h3 id="变量声明提升（Hoisting）">变量声明提升（Hoisting）</h3><p>JavaScript 会提升变量声明。这意味着 var 表达式和 function 声明都将会被提升到当前作用域的顶部。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">bar();</span><br><span class="line"><span class="keyword">var</span> bar = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line"><span class="keyword">var</span> someValue = <span class="number">42</span>;</span><br><span class="line"></span><br><span class="line">test();</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">false</span>) &#123;</span><br><span class="line">        goo = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> goo = <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">var</span> e = data[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码在运行之前将会被转化。JavaScript 将会把 var 表达式和 function 声明提升到当前作用域的顶部。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// var 表达式被移动到这里</span></span><br><span class="line"><span class="keyword">var</span> bar, someValue; <span class="comment">// 缺省值是 'undefined'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数声明也会提升</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> goo, i, e; <span class="comment">// 没有块级作用域，这些变量被移动到函数顶部</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">false</span>) &#123;</span><br><span class="line">        goo = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        goo = <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">        e = data[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bar(); <span class="comment">// 出错：TypeError，因为 bar 依然是 'undefined'</span></span><br><span class="line">someValue = <span class="number">42</span>; <span class="comment">// 赋值语句不会被提升规则（hoisting）影响</span></span><br><span class="line">bar = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line"></span><br><span class="line">test();</span><br></pre></td></tr></table></figure>
<p>没有块级作用域不仅导致 var 表达式被从循环内移到外部，而且使一些 if 表达式更难看懂。</p>
<p>在原来代码中，if 表达式看起来修改了全局变量 goo，实际上在提升规则被应用后，却是在修改局部变量。</p>
<p>如果没有提升规则（hoisting）的知识，下面的代码看起来会抛出异常 ReferenceError。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 检查 SomeImportantThing 是否已经被初始化</span></span><br><span class="line"><span class="keyword">if</span> (!SomeImportantThing) &#123;</span><br><span class="line">    <span class="keyword">var</span> SomeImportantThing = &#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实际上，上面的代码正常运行，因为 var 表达式会被提升到全局作用域的顶部。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> SomeImportantThing;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 其它一些代码，可能会初始化 SomeImportantThing，也可能不会</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 检查是否已经被初始化</span></span><br><span class="line"><span class="keyword">if</span> (!SomeImportantThing) &#123;</span><br><span class="line">    SomeImportantThing = &#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>译者注：在 Nettuts+ 网站有一篇介绍 hoisting 的文章，其中的代码很有启发性。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 译者注：来自 Nettuts+ 的一段代码，生动的阐述了 JavaScript 中变量声明提升规则</span></span><br><span class="line"><span class="keyword">var</span> myvar = <span class="string">'my value'</span>;  </span><br><span class="line"></span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;  </span><br><span class="line">    alert(myvar); <span class="comment">// undefined  </span></span><br><span class="line">    <span class="keyword">var</span> myvar = <span class="string">'local value'</span>;  </span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>
<h3 id="名称解析顺序">名称解析顺序</h3><p>JavaScript 中的所有作用域，包括全局作用域，都有一个特别的名称 this 指向当前对象。</p>
<p>函数作用域内也有默认的变量 arguments，其中包含了传递到函数中的参数。</p>
<p>比如，当访问函数内的 foo 变量时，JavaScript 会按照下面顺序查找：</p>
<ol>
<li>当前作用域内是否有 var foo 的定义。</li>
<li>函数形式参数是否有使用 foo 名称的。</li>
<li>函数自身是否叫做 foo。</li>
<li>回溯到上一级作用域，然后从 #1 重新开始。</li>
</ol>
<h3 id="命名空间">命名空间</h3><p>只有一个全局作用域导致的常见错误是命名冲突。在 JavaScript中，这可以通过 匿名包装器 轻松解决。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 函数创建一个命名空间</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">window</span>.foo = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 对外公开的函数，创建了闭包</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">&#125;)(); <span class="comment">// 立即执行此匿名函数</span></span><br></pre></td></tr></table></figure>
<p>匿名函数被认为是 表达式；因此为了可调用性，它们首先会被执行。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">( <span class="comment">// 小括号内的函数首先被执行</span></span><br><span class="line"><span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">) <span class="comment">// 并且返回函数对象</span></span><br><span class="line">() <span class="comment">// 调用上面的执行结果，也就是函数对象</span></span><br></pre></td></tr></table></figure>
<p>有一些其他的调用函数表达式的方法，比如下面的两种方式语法不同，但是效果一模一样。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 另外两种方式</span></span><br><span class="line">+<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;();</span><br><span class="line">!<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;();</span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;());</span><br></pre></td></tr></table></figure>
<h3 id="结论-1">结论</h3><p>推荐使用匿名包装器（译者注：也就是自执行的匿名函数）来创建命名空间。这样不仅可以防止命名冲突， 而且有利于程序的模块化。</p>
<p>另外，使用全局变量被认为是不好的习惯。这样的代码容易产生错误并且维护成本较高。</p>
<h1 id="数组">数组</h1><h2 id="数组遍历与属性">数组遍历与属性</h2><p>虽然在 JavaScript 中数组是对象，但是没有好的理由去使用 for in 循环 遍历数组。 相反，有一些好的理由不去使用 for in 遍历数组。</p>
<p>注意: JavaScript 中数组不是 关联数组。 JavaScript 中只有对象 来管理键值的对应关系。但是关联数组是保持顺序的，而对象不是。<br>由于 for in 循环会枚举原型链上的所有属性，唯一过滤这些属性的方式是使用 hasOwnProperty 函数， 因此会比普通的 for 循环慢上好多倍。</p>
<h3 id="遍历">遍历</h3><p>为了达到遍历数组的最佳性能，推荐使用经典的 for 循环。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> list = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, ...... <span class="number">100000000</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>, l = list.length; i &lt; l; i++) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(list[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码有一个处理，就是通过 l = list.length 来缓存数组的长度。</p>
<p>虽然 length 是数组的一个属性，但是在每次循环中访问它还是有性能开销。 可能最新的 JavaScript 引擎在这点上做了优化，但是我们没法保证自己的代码是否运行在这些最近的引擎之上。</p>
<p>实际上，不使用缓存数组长度的方式比缓存版本要慢很多。</p>
<h3 id="length_属性">length 属性</h3><p>length 属性的 getter 方式会简单的返回数组的长度，而 setter 方式会截断数组。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>];</span><br><span class="line">foo.length = <span class="number">3</span>;</span><br><span class="line">foo; <span class="comment">// [1, 2, 3]</span></span><br><span class="line"></span><br><span class="line">foo.length = <span class="number">6</span>;</span><br><span class="line">foo; <span class="comment">// [1, 2, 3]</span></span><br></pre></td></tr></table></figure>
<p>译者注： 在 Firebug 中查看此时 foo 的值是： [1, 2, 3, undefined, undefined, undefined] 但是这个结果并不准确，如果你在 Chrome 的控制台查看 foo 的结果，你会发现是这样的： [1, 2, 3] 因为在 JavaScript 中 undefined 是一个变量，注意是变量不是关键字，因此上面两个结果的意义是完全不相同的。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 译者注：为了验证，我们来执行下面代码，看序号 5 是否存在于 foo 中。</span></span><br><span class="line"><span class="number">5</span> <span class="keyword">in</span> foo; <span class="comment">// 不管在 Firebug 或者 Chrome 都返回 false</span></span><br><span class="line">foo[<span class="number">5</span>] = <span class="literal">undefined</span>;</span><br><span class="line"><span class="number">5</span> <span class="keyword">in</span> foo; <span class="comment">// 不管在 Firebug 或者 Chrome 都返回 true</span></span><br></pre></td></tr></table></figure>
<p>为 length 设置一个更小的值会截断数组，但是增大 length 属性值不会对数组产生影响。</p>
<h3 id="结论-2">结论</h3><p>为了更好的性能，推荐使用普通的 for 循环并缓存数组的 length 属性。 使用 for in 遍历数组被认为是不好的代码习惯并倾向于产生错误和导致性能问题。</p>
<h2 id="Array_构造函数">Array 构造函数</h2><p>由于 Array 的构造函数在如何处理参数时有点模棱两可，因此总是推荐使用数组的字面语法 - [] - 来创建数组。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]; <span class="comment">// 结果: [1, 2, 3]</span></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>); <span class="comment">// 结果: [1, 2, 3]</span></span><br><span class="line"></span><br><span class="line">[<span class="number">3</span>]; <span class="comment">// 结果: [3]</span></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">3</span>); <span class="comment">// 结果: [] </span></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Array</span>(<span class="string">'3'</span>) <span class="comment">// 结果: ['3']</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 译者注：因此下面的代码将会使人很迷惑</span></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>); <span class="comment">// 结果: [3, 4, 5] </span></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">3</span>) <span class="comment">// 结果: []，此数组长度为 3</span></span><br></pre></td></tr></table></figure>
<p>由于只有一个参数传递到构造函数中（译者注：指的是 new Array(3); 这种调用方式），并且这个参数是数字，构造函数会返回一个 length 属性被设置为此参数的空数组。 需要特别注意的是，此时只有 length 属性被设置，真正的数组并没有生成。</p>
<p>译者注：在 Firebug 中，你会看到 [undefined, undefined, undefined]，这其实是不对的。在上一节有详细的分析。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">3</span>);</span><br><span class="line">arr[<span class="number">1</span>]; <span class="comment">// undefined</span></span><br><span class="line"><span class="number">1</span> <span class="keyword">in</span> arr; <span class="comment">// false, 数组还没有生成</span></span><br></pre></td></tr></table></figure>
<p>这种优先于设置数组长度属性的做法只在少数几种情况下有用，比如需要循环字符串，可以避免 for 循环的麻烦。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Array</span>(count + <span class="number">1</span>).join(stringToRepeat);</span><br></pre></td></tr></table></figure>
<h3 id="结论-3">结论</h3><p>应该尽量避免使用数组构造函数创建新数组。推荐使用数组的字面语法。它们更加短小和简洁，因此增加了代码的可读性。</p>
<h1 id="类型">类型</h1><h2 id="相等与比较">相等与比较</h2><p>JavaScript 有两种方式判断两个值是否相等。</p>
<h3 id="等于操作符">等于操作符</h3><p>等于操作符由两个等号组成：==</p>
<p>JavaScript 是弱类型语言，这就意味着，等于操作符会为了比较两个值而进行强制类型转换。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">""</span>           ==   <span class="string">"0"</span>           <span class="comment">// false</span></span><br><span class="line"><span class="number">0</span>            ==   <span class="string">""</span>            <span class="comment">// true</span></span><br><span class="line"><span class="number">0</span>            ==   <span class="string">"0"</span>           <span class="comment">// true</span></span><br><span class="line"><span class="literal">false</span>        ==   <span class="string">"false"</span>       <span class="comment">// false</span></span><br><span class="line"><span class="literal">false</span>        ==   <span class="string">"0"</span>           <span class="comment">// true</span></span><br><span class="line"><span class="literal">false</span>        ==   <span class="literal">undefined</span>     <span class="comment">// false</span></span><br><span class="line"><span class="literal">false</span>        ==   <span class="literal">null</span>          <span class="comment">// false</span></span><br><span class="line"><span class="literal">null</span>         ==   <span class="literal">undefined</span>     <span class="comment">// true</span></span><br><span class="line"><span class="string">" \t\r\n"</span>    ==   <span class="number">0</span>             <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>上面的表格展示了强制类型转换，这也是使用 == 被广泛认为是不好编程习惯的主要原因， 由于它的复杂转换规则，会导致难以跟踪的问题。</p>
<p>此外，强制类型转换也会带来性能消耗，比如一个字符串为了和一个数字进行比较，必须事先被强制转换为数字。</p>
<h3 id="严格等于操作符">严格等于操作符</h3><p>严格等于操作符由三个等号组成：===</p>
<p>不像普通的等于操作符，严格等于操作符不会进行强制类型转换。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">""</span>           ===   <span class="string">"0"</span>           <span class="comment">// false</span></span><br><span class="line"><span class="number">0</span>            ===   <span class="string">""</span>            <span class="comment">// false</span></span><br><span class="line"><span class="number">0</span>            ===   <span class="string">"0"</span>           <span class="comment">// false</span></span><br><span class="line"><span class="literal">false</span>        ===   <span class="string">"false"</span>       <span class="comment">// false</span></span><br><span class="line"><span class="literal">false</span>        ===   <span class="string">"0"</span>           <span class="comment">// false</span></span><br><span class="line"><span class="literal">false</span>        ===   <span class="literal">undefined</span>     <span class="comment">// false</span></span><br><span class="line"><span class="literal">false</span>        ===   <span class="literal">null</span>          <span class="comment">// false</span></span><br><span class="line"><span class="literal">null</span>         ===   <span class="literal">undefined</span>     <span class="comment">// false</span></span><br><span class="line"><span class="string">" \t\r\n"</span>    ===   <span class="number">0</span>             <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<p>上面的结果更加清晰并有利于代码的分析。如果两个操作数类型不同就肯定不相等也有助于性能的提升。</p>
<h3 id="比较对象">比较对象</h3><p>虽然 == 和 === 操作符都是等于操作符，但是当其中有一个操作数为对象时，行为就不同了。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#125; === &#123;&#125;;                   <span class="comment">// false</span></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">'foo'</span>) === <span class="string">'foo'</span>; <span class="comment">// false</span></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Number</span>(<span class="number">10</span>) === <span class="number">10</span>;       <span class="comment">// false</span></span><br><span class="line"><span class="keyword">var</span> foo = &#123;&#125;;</span><br><span class="line">foo === foo;                 <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>这里等于操作符比较的不是值是否相等，而是是否属于同一个身份；也就是说，只有对象的同一个实例才被认为是相等的。 这有点像 Python 中的 is 和 C 中的指针比较。</p>
<p>注意:为了更直观的看到==和===的区别,可以参见JavaScript Equality Table</p>
<h3 id="结论-4">结论</h3><p>强烈推荐使用严格等于操作符。如果类型需要转换，应该在比较之前显式的转换， 而不是使用语言本身复杂的强制转换规则。</p>
<h2 id="typeof_操作符">typeof 操作符</h2><p>typeof 操作符（和 instanceof 一起）或许是 JavaScript 中最大的设计缺陷， 因为几乎不可能从它们那里得到想要的结果。</p>
<p>尽管 instanceof 还有一些极少数的应用场景，typeof 只有一个实际的应用（译者注：这个实际应用是用来检测一个对象是否已经定义或者是否已经赋值）， 而这个应用却不是用来检查对象的类型。</p>
<p>注意: 由于 typeof 也可以像函数的语法被调用，比如 typeof(obj)，但这并不是一个函数调用。 那两个小括号只是用来计算一个表达式的值，这个返回值会作为 typeof 操作符的一个操作数。 实际上不存在名为 typeof 的函数。</p>
<h3 id="JavaScript_类型表格">JavaScript 类型表格</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Value               Class      Type</span><br><span class="line">-------------------------------------</span><br><span class="line">"foo"               String     string</span><br><span class="line">new String("foo")   String     object</span><br><span class="line">1.2                 Number     number</span><br><span class="line">new Number(1.2)     Number     object</span><br><span class="line">true                Boolean    boolean</span><br><span class="line">new Boolean(true)   Boolean    object</span><br><span class="line">new Date()          Date       object</span><br><span class="line">new Error()         Error      object</span><br><span class="line">[1,2,3]             Array      object</span><br><span class="line">new Array(1, 2, 3)  Array      object</span><br><span class="line">new Function("")    Function   function</span><br><span class="line">/abc/g              RegExp     object (function in Nitro/V8)</span><br><span class="line">new RegExp("meow")  RegExp     object (function in Nitro/V8)</span><br><span class="line">&#123;&#125;                  Object     object</span><br><span class="line">new Object()        Object     object</span><br></pre></td></tr></table></figure>
<p>上面表格中，Type 一列表示 typeof 操作符的运算结果。可以看到，这个值在大多数情况下都返回 “object”。</p>
<p>Class 一列表示对象的内部属性 [[Class]] 的值。</p>
<p>JavaScript 标准文档中定义: [[Class]] 的值只可能是下面字符串中的一个： Arguments, Array, Boolean, Date, Error, Function, JSON, Math, Number, Object, RegExp, String.<br>为了获取对象的 [[Class]]，我们需要使用定义在 Object.prototype 上的方法 toString。</p>
<h3 id="对象的类定义">对象的类定义</h3><p>JavaScript 标准文档只给出了一种获取 [[Class]] 值的方法，那就是使用 Object.prototype.toString。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">is</span>(<span class="params">type, obj</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> clas = <span class="built_in">Object</span>.prototype.toString.call(obj).slice(<span class="number">8</span>, -<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> obj !== <span class="literal">undefined</span> &amp;&amp; obj !== <span class="literal">null</span> &amp;&amp; clas === type;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">is(<span class="string">'String'</span>, <span class="string">'test'</span>); <span class="comment">// true</span></span><br><span class="line">is(<span class="string">'String'</span>, <span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">'test'</span>)); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>上面例子中，Object.prototype.toString 方法被调用，this 被设置为了需要获取 [[Class]] 值的对象。</p>
<p>译者注：Object.prototype.toString 返回一种标准格式字符串，所以上例可以通过 slice 截取指定位置的字符串，如下所示：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.prototype.toString.call([])    <span class="comment">// "[object Array]"</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(&#123;&#125;)    <span class="comment">// "[object Object]"</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="number">2</span>)    <span class="comment">// "[object Number]"</span></span><br></pre></td></tr></table></figure>
<p>译者注：这种变化可以从 IE8 和 Firefox 4 中看出区别，如下所示：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// IE8</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="literal">null</span>)    <span class="comment">// "[object Object]"</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="literal">undefined</span>)    <span class="comment">// "[object Object]"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Firefox 4</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="literal">null</span>)    <span class="comment">// "[object Null]"</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="literal">undefined</span>)    <span class="comment">// "[object Undefined]"</span></span><br></pre></td></tr></table></figure>
<h3 id="测试为定义变量">测试为定义变量</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typeof</span> foo !== <span class="string">'undefined'</span></span><br></pre></td></tr></table></figure>
<p>上面代码会检测 foo 是否已经定义；如果没有定义而直接使用会导致 ReferenceError 的异常。 这是 typeof 唯一有用的地方。</p>
<h3 id="结论-5">结论</h3><p>为了检测一个对象的类型，强烈推荐使用 Object.prototype.toString 方法； 因为这是唯一一个可依赖的方式。正如上面表格所示，typeof 的一些返回值在标准文档中并未定义， 因此不同的引擎实现可能不同。</p>
<p>除非为了检测一个变量是否已经定义，我们应尽量避免使用 typeof 操作符。</p>
<h2 id="instanceof_操作符">instanceof 操作符</h2><p>instanceof 操作符用来比较两个操作数的构造函数。只有在比较自定义的对象时才有意义。 如果用来比较内置类型，将会和 typeof 操作符 一样用处不大。</p>
<h3 id="比较自定义对象">比较自定义对象</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Foo</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Bar</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">Bar.prototype = <span class="keyword">new</span> Foo();</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Bar() <span class="keyword">instanceof</span> Bar; <span class="comment">// true</span></span><br><span class="line"><span class="keyword">new</span> Bar() <span class="keyword">instanceof</span> Foo; <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果仅仅设置 Bar.prototype 为函数 Foo 本身，而不是 Foo 构造函数的一个实例</span></span><br><span class="line">Bar.prototype = Foo;</span><br><span class="line"><span class="keyword">new</span> Bar() <span class="keyword">instanceof</span> Foo; <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<h3 id="instanceof_比较内置类型">instanceof 比较内置类型</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">'foo'</span>) <span class="keyword">instanceof</span> <span class="built_in">String</span>; <span class="comment">// true</span></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">'foo'</span>) <span class="keyword">instanceof</span> <span class="built_in">Object</span>; <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="string">'foo'</span> <span class="keyword">instanceof</span> <span class="built_in">String</span>; <span class="comment">// false</span></span><br><span class="line"><span class="string">'foo'</span> <span class="keyword">instanceof</span> <span class="built_in">Object</span>; <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<p>有一点需要注意，instanceof 用来比较属于不同 JavaScript 上下文的对象（比如，浏览器中不同的文档结构）时将会出错， 因为它们的构造函数不会是同一个对象。</p>
<h3 id="结论-6">结论</h3><p>instanceof 操作符应该仅仅用来比较来自同一个 JavaScript 上下文的自定义对象。 正如 typeof 操作符一样，任何其它的用法都应该是避免的。</p>
<h2 id="类型转换">类型转换</h2><p>JavaScript 是弱类型语言，所以会在任何可能的情况下应用强制类型转换。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 下面的比较结果是：true</span></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Number</span>(<span class="number">10</span>) == <span class="number">10</span>; <span class="comment">// Number.toString() 返回的字符串被再次转换为数字</span></span><br><span class="line"></span><br><span class="line"><span class="number">10</span> == <span class="string">'10'</span>;           <span class="comment">// 字符串被转换为数字</span></span><br><span class="line"><span class="number">10</span> == <span class="string">'+10 '</span>;         <span class="comment">// 同上</span></span><br><span class="line"><span class="number">10</span> == <span class="string">'010'</span>;          <span class="comment">// 同上 </span></span><br><span class="line"><span class="built_in">isNaN</span>(<span class="literal">null</span>) == <span class="literal">false</span>; <span class="comment">// null 被转换为数字 0</span></span><br><span class="line">                      <span class="comment">// 0 当然不是一个 NaN（译者注：否定之否定）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 下面的比较结果是：false</span></span><br><span class="line"><span class="number">10</span> == <span class="number">010</span>;</span><br><span class="line"><span class="number">10</span> == <span class="string">'-10'</span>;</span><br></pre></td></tr></table></figure>
<p>为了避免上面复杂的强制类型转换，强烈推荐使用严格的等于操作符。 虽然这可以避免大部分的问题，但 JavaScript 的弱类型系统仍然会导致一些其它问题。</p>
<h3 id="内置类型的构造函数">内置类型的构造函数</h3><p>内置类型（比如 Number 和 String）的构造函数在被调用时，使用或者不使用 new 的结果完全不同。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Number</span>(<span class="number">10</span>) === <span class="number">10</span>;     <span class="comment">// False, 对象与数字的比较</span></span><br><span class="line"><span class="built_in">Number</span>(<span class="number">10</span>) === <span class="number">10</span>;         <span class="comment">// True, 数字与数字的比较</span></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Number</span>(<span class="number">10</span>) + <span class="number">0</span> === <span class="number">10</span>; <span class="comment">// True, 由于隐式的类型转换</span></span><br></pre></td></tr></table></figure>
<p>使用内置类型 Number 作为构造函数将会创建一个新的 Number 对象， 而在不使用 new 关键字的 Number 函数更像是一个数字转换器。</p>
<p>另外，在比较中引入对象的字面值将会导致更加复杂的强制类型转换。</p>
<p>最好的选择是把要比较的值显式的转换为三种可能的类型之一。</p>
<h3 id="转换为字符串">转换为字符串</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">''</span> + <span class="number">10</span> === <span class="string">'10'</span>; <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>将一个值加上空字符串可以轻松转换为字符串类型。</p>
<h3 id="转换为数字">转换为数字</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">+<span class="string">'10'</span> === <span class="number">10</span>; <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>使用一元的加号操作符，可以把字符串转换为数字。</p>
<p>译者注：字符串转换为数字的常用方法：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">+<span class="string">'010'</span> === <span class="number">10</span></span><br><span class="line"><span class="built_in">Number</span>(<span class="string">'010'</span>) === <span class="number">10</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">'010'</span>, <span class="number">10</span>) === <span class="number">10</span>  <span class="comment">// 用来转换为整数</span></span><br><span class="line"></span><br><span class="line">+<span class="string">'010.2'</span> === <span class="number">10.2</span></span><br><span class="line"><span class="built_in">Number</span>(<span class="string">'010.2'</span>) === <span class="number">10.2</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">'010.2'</span>, <span class="number">10</span>) === <span class="number">10</span></span><br></pre></td></tr></table></figure>
<h3 id="转换为布尔型">转换为布尔型</h3><p>通过使用 否 操作符两次，可以把一个值转换为布尔型。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">!!<span class="string">'foo'</span>;   <span class="comment">// true</span></span><br><span class="line">!!<span class="string">''</span>;      <span class="comment">// false</span></span><br><span class="line">!!<span class="string">'0'</span>;     <span class="comment">// true</span></span><br><span class="line">!!<span class="string">'1'</span>;     <span class="comment">// true</span></span><br><span class="line">!!<span class="string">'-1'</span>     <span class="comment">// true</span></span><br><span class="line">!!&#123;&#125;;      <span class="comment">// true</span></span><br><span class="line">!!<span class="literal">true</span>;    <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<h1 id="核心">核心</h1><h2 id="为什么不要使用_eval">为什么不要使用 eval</h2><p>eval 函数会在当前作用域中执行一段 JavaScript 代码字符串。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> foo = <span class="number">2</span>;</span><br><span class="line">    <span class="built_in">eval</span>(<span class="string">'foo = 3'</span>);</span><br><span class="line">    <span class="keyword">return</span> foo;</span><br><span class="line">&#125;</span><br><span class="line">test(); <span class="comment">// 3</span></span><br><span class="line">foo; <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>
<p>但是 eval 只在被直接调用并且调用函数就是 eval 本身时，才在当前作用域中执行。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> foo = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">var</span> bar = <span class="built_in">eval</span>;</span><br><span class="line">    bar(<span class="string">'foo = 3'</span>);</span><br><span class="line">    <span class="keyword">return</span> foo;</span><br><span class="line">&#125;</span><br><span class="line">test(); <span class="comment">// 2</span></span><br><span class="line">foo; <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>
<p>译者注：上面的代码等价于在全局作用域中调用 eval，和下面两种写法效果一样：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 写法一：直接调用全局作用域下的 foo 变量</span></span><br><span class="line"><span class="keyword">var</span> foo = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> foo = <span class="number">2</span>;</span><br><span class="line">    <span class="built_in">window</span>.foo = <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">return</span> foo;</span><br><span class="line">&#125;</span><br><span class="line">test(); <span class="comment">// 2</span></span><br><span class="line">foo; <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 写法二：使用 call 函数修改 eval 执行的上下文为全局作用域</span></span><br><span class="line"><span class="keyword">var</span> foo = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> foo = <span class="number">2</span>;</span><br><span class="line">    <span class="built_in">eval</span>.call(<span class="built_in">window</span>, <span class="string">'foo = 3'</span>);</span><br><span class="line">    <span class="keyword">return</span> foo;</span><br><span class="line">&#125;</span><br><span class="line">test(); <span class="comment">// 2</span></span><br><span class="line">foo; <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>
<p>在任何情况下我们都应该避免使用 eval 函数。99.9% 使用 eval 的场景都有不使用 eval 的解决方案。</p>
<h3 id="伪装的_eval">伪装的 eval</h3><p>定时函数 setTimeout 和 setInterval 都可以接受字符串作为它们的第一个参数。 这个字符串总是在全局作用域中执行，因此 eval 在这种情况下没有被直接调用。</p>
<h3 id="安全问题">安全问题</h3><p>eval 也存在安全问题，因为它会执行任意传给它的代码， 在代码字符串未知或者是来自一个不信任的源时，绝对不要使用 eval 函数。</p>
<h3 id="结论-7">结论</h3><p>绝对不要使用 eval，任何使用它的代码都会在它的工作方式，性能和安全性方面受到质疑。 如果一些情况必须使用到 eval 才能正常工作，首先它的设计会受到质疑，这不应该是首选的解决方案， 一个更好的不使用 eval 的解决方案应该得到充分考虑并优先采用。</p>
<h2 id="undefined_和_null">undefined 和 null</h2><p>JavaScript 有两个表示‘空’的值，其中比较有用的是 undefined。</p>
<p>undefined 的值</p>
<p>undefined 是一个值为 undefined 的类型。</p>
<p>这个语言也定义了一个全局变量，它的值是 undefined，这个变量也被称为 undefined。 但是这个变量不是一个常量，也不是一个关键字。这意味着它的值可以轻易被覆盖。</p>
<p>ES5 提示: 在 ECMAScript 5 的严格模式下，undefined 不再是 可写的了。 但是它的名称仍然可以被隐藏，比如定义一个函数名为 undefined。<br>下面的情况会返回 undefined 值：</p>
<ul>
<li>访问未修改的全局变量 undefined。</li>
<li>由于没有定义 return 表达式的函数隐式返回。</li>
<li>return 表达式没有显式的返回任何内容。</li>
<li>访问不存在的属性。</li>
<li>函数参数没有被显式的传递值。</li>
<li>任何被设置为 undefined 值的变量。</li>
</ul>
<h3 id="处理_undefined_值的改变">处理 undefined 值的改变</h3><p>由于全局变量 undefined 只是保存了 undefined 类型实际值的副本， 因此对它赋新值不会改变类型 undefined 的值。</p>
<p>然而，为了方便其它变量和 undefined 做比较，我们需要事先获取类型 undefined 的值。</p>
<p>为了避免可能对 undefined 值的改变，一个常用的技巧是使用一个传递到匿名包装器的额外参数。 在调用时，这个参数不会获取任何值。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="literal">undefined</span> = <span class="number">123</span>;</span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params">something, foo, undefined</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 局部作用域里的 undefined 变量重新获得了 `undefined` 值</span></span><br><span class="line"></span><br><span class="line">&#125;)(<span class="string">'Hello World'</span>, <span class="number">42</span>);</span><br></pre></td></tr></table></figure>
<p>另外一种达到相同目的方法是在函数内使用变量声明。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="literal">undefined</span> = <span class="number">123</span>;</span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params">something, foo</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> <span class="literal">undefined</span>;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">&#125;)(<span class="string">'Hello World'</span>, <span class="number">42</span>);</span><br></pre></td></tr></table></figure>
<p>这里唯一的区别是，在压缩后并且函数内没有其它需要使用 var 声明变量的情况下，这个版本的代码会多出 4 个字节的代码。</p>
<h3 id="null_的用处">null 的用处</h3><p>JavaScript 中的 undefined 的使用场景类似于其它语言中的 null，实际上 JavaScript 中的 null 是另外一种数据类型。</p>
<p>它在 JavaScript 内部有一些使用场景（比如声明原型链的终结 Foo.prototype = null），但是大多数情况下都可以使用 undefined 来代替。</p>
<h2 id="自动分号插入">自动分号插入</h2><p>尽管 JavaScript 有 C 的代码风格，但是它不强制要求在代码中使用分号，实际上可以省略它们。</p>
<p>JavaScript 不是一个没有分号的语言，恰恰相反上它需要分号来就解析源代码。 因此 JavaScript 解析器在遇到由于缺少分号导致的解析错误时，会自动在源代码中插入分号。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">&#125; <span class="comment">// 解析错误，分号丢失</span></span><br><span class="line">test()</span><br></pre></td></tr></table></figure>
<p>自动插入分号，解析器重新解析。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">&#125;; <span class="comment">// 没有错误，解析继续</span></span><br><span class="line">test()</span><br></pre></td></tr></table></figure>
<p>自动的分号插入被认为是 JavaScript 语言最大的设计缺陷之一，因为它能改变代码的行为。</p>
<h3 id="工作原理">工作原理</h3><p>下面的代码没有分号，因此解析器需要自己判断需要在哪些地方插入分号。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params">window, undefined</span>) </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params">options</span>) </span>&#123;</span><br><span class="line">        log(<span class="string">'testing!'</span>)</span><br><span class="line"></span><br><span class="line">        (options.list || []).forEach(<span class="function"><span class="keyword">function</span>(<span class="params">i</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">        &#125;)</span><br><span class="line"></span><br><span class="line">        options.value.test(</span><br><span class="line">            <span class="string">'long string to pass here'</span>,</span><br><span class="line">            <span class="string">'and another long string to pass'</span></span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">        &#123;</span><br><span class="line">            foo: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">window</span>.test = test</span><br><span class="line"></span><br><span class="line">&#125;)(<span class="built_in">window</span>)</span><br><span class="line"></span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params">window</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">window</span>.someLibrary = &#123;&#125;</span><br><span class="line">&#125;)(<span class="built_in">window</span>)</span><br></pre></td></tr></table></figure>
<p>下面是解析器”猜测”的结果。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params">window, undefined</span>) </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params">options</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 没有插入分号，两行被合并为一行</span></span><br><span class="line">        log(<span class="string">'testing!'</span>)(options.list || []).forEach(<span class="function"><span class="keyword">function</span>(<span class="params">i</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">        &#125;); <span class="comment">// &lt;- 插入分号</span></span><br><span class="line"></span><br><span class="line">        options.value.test(</span><br><span class="line">            <span class="string">'long string to pass here'</span>,</span><br><span class="line">            <span class="string">'and another long string to pass'</span></span><br><span class="line">        ); <span class="comment">// &lt;- 插入分号</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span>; <span class="comment">// &lt;- 插入分号, 改变了 return 表达式的行为</span></span><br><span class="line">        &#123; <span class="comment">// 作为一个代码段处理</span></span><br><span class="line">            foo: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125; </span><br><span class="line">        &#125;; <span class="comment">// &lt;- 插入分号</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">window</span>.test = test; <span class="comment">// &lt;- 插入分号</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 两行又被合并了</span></span><br><span class="line">&#125;)(<span class="built_in">window</span>)(<span class="function"><span class="keyword">function</span>(<span class="params">window</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">window</span>.someLibrary = &#123;&#125;; <span class="comment">// &lt;- 插入分号</span></span><br><span class="line">&#125;)(<span class="built_in">window</span>); <span class="comment">//&lt;- 插入分号</span></span><br></pre></td></tr></table></figure>
<p>解析器显著改变了上面代码的行为，在另外一些情况下也会做出错误的处理。</p>
<h3 id="前置括号">前置括号</h3><p>在前置括号的情况下，解析器不会自动插入分号。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">log(<span class="string">'testing!'</span>)</span><br><span class="line">(options.list || []).forEach(<span class="function"><span class="keyword">function</span>(<span class="params">i</span>) </span>&#123;&#125;)</span><br></pre></td></tr></table></figure>
<p>上面代码被解析器转换为一行。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">log(<span class="string">'testing!'</span>)(options.list || []).forEach(<span class="function"><span class="keyword">function</span>(<span class="params">i</span>) </span>&#123;&#125;)</span><br></pre></td></tr></table></figure>
<p>log 函数的执行结果极大可能不是函数；这种情况下就会出现 TypeError 的错误，详细错误信息可能是 undefined is not a function。</p>
<h3 id="结论-8">结论</h3><p>建议绝对不要省略分号，同时也提倡将花括号和相应的表达式放在一行， 对于只有一行代码的 if 或者 else 表达式，也不应该省略花括号。 这些良好的编程习惯不仅可以提到代码的一致性，而且可以防止解析器改变代码行为的错误处理。</p>
<h1 id="其它">其它</h1><h2 id="setTimeout_和_setInterval">setTimeout 和 setInterval</h2><p>由于 JavaScript 是异步的，可以使用 setTimeout 和 setInterval 来计划执行函数。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="keyword">var</span> id = setTimeout(foo, <span class="number">1000</span>); <span class="comment">// 返回一个大于零的数字</span></span><br></pre></td></tr></table></figure>
<p>当 setTimeout 被调用时，它会返回一个 ID 标识并且计划在将来大约 1000 毫秒后调用 foo 函数。 foo 函数只会被执行一次。</p>
<p>基于 JavaScript 引擎的计时策略，以及本质上的单线程运行方式，所以其它代码的运行可能会阻塞此线程。 因此没法确保函数会在 setTimeout 指定的时刻被调用。</p>
<p>作为第一个参数的函数将会在全局作用域中执行，因此函数内的 this 将会指向这个全局对象。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.value = <span class="number">42</span>;</span><br><span class="line">    <span class="keyword">this</span>.method = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="comment">// this 指向全局对象</span></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.value); <span class="comment">// 输出：undefined</span></span><br><span class="line">    &#125;;</span><br><span class="line">    setTimeout(<span class="keyword">this</span>.method, <span class="number">500</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">new</span> Foo();</span><br></pre></td></tr></table></figure>
<h3 id="setInterval_的堆调用">setInterval 的堆调用</h3><p>setTimeout 只会执行回调函数一次，不过 setInterval - 正如名字建议的 - 会每隔 X 毫秒执行函数一次。 但是却不鼓励使用这个函数。</p>
<p>当回调函数的执行被阻塞时，setInterval 仍然会发布更多的回调指令。在很小的定时间隔情况下，这会导致回调函数被堆积起来。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 阻塞执行 1 秒</span></span><br><span class="line">&#125;</span><br><span class="line">setInterval(foo, <span class="number">100</span>);</span><br></pre></td></tr></table></figure>
<p>上面代码中，foo 会执行一次随后被阻塞了一秒钟。</p>
<p>在 foo 被阻塞的时候，setInterval 仍然在组织将来对回调函数的调用。 因此，当第一次 foo 函数调用结束时，已经有 10 次函数调用在等待执行。</p>
<h3 id="处理可能的阻塞调用">处理可能的阻塞调用</h3><p>最简单也是最容易控制的方案，是在回调函数内部使用 setTimeout 函数。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 阻塞执行 1 秒</span></span><br><span class="line">    setTimeout(foo, <span class="number">100</span>);</span><br><span class="line">&#125;</span><br><span class="line">foo();</span><br></pre></td></tr></table></figure>
<p>这样不仅封装了 setTimeout 回调函数，而且阻止了调用指令的堆积，可以有更多的控制。 foo 函数现在可以控制是否继续执行还是终止执行。</p>
<h3 id="手工清空定时器">手工清空定时器</h3><p>可以通过将定时时产生的 ID 标识传递给 clearTimeout 或者 clearInterval 函数来清除定时， 至于使用哪个函数取决于调用的时候使用的是 setTimeout 还是 setInterval。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> id = setTimeout(foo, <span class="number">1000</span>);</span><br><span class="line">clearTimeout(id);</span><br></pre></td></tr></table></figure>
<h3 id="清除所有定时器">清除所有定时器</h3><p>由于没有内置的清除所有定时器的方法，可以采用一种暴力的方式来达到这一目的。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 清空"所有"的定时器</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">1</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">    clearTimeout(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可能还有些定时器不会在上面代码中被清除（译者注：如果定时器调用时返回的 ID 值大于 1000）， 因此我们可以事先保存所有的定时器 ID，然后一把清除。</p>
<h3 id="隐藏使用_eval">隐藏使用 eval</h3><p>setTimeout 和 setInterval 也接受第一个参数为字符串的情况。 这个特性绝对不要使用，因为它在内部使用了 eval。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 将会被调用</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 不会被调用</span></span><br><span class="line">    &#125;</span><br><span class="line">    setTimeout(<span class="string">'foo()'</span>, <span class="number">1000</span>);</span><br><span class="line">&#125;</span><br><span class="line">bar();</span><br></pre></td></tr></table></figure>
<p>由于 eval 在这种情况下不是被直接调用，因此传递到 setTimeout 的字符串会自全局作用域中执行； 因此，上面的回调函数使用的不是定义在 bar 作用域中的局部变量 foo。</p>
<p>建议不要在调用定时器函数时，为了向回调函数传递参数而使用字符串的形式。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">a, b, c</span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不要这样做</span></span><br><span class="line">setTimeout(<span class="string">'foo(1,2, 3)'</span>, <span class="number">1000</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以使用匿名函数完成相同功能</span></span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    foo(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">&#125;, <span class="number">1000</span>)</span><br></pre></td></tr></table></figure>
<h3 id="结论-9">结论</h3><p>绝对不要使用字符串作为 setTimeout 或者 setInterval 的第一个参数， 这么写的代码明显质量很差。当需要向回调函数传递参数时，可以创建一个匿名函数，在函数内执行真实的回调函数。</p>
<p>另外，应该避免使用 setInterval，因为它的定时执行不会被 JavaScript 阻塞。</p>
</span>
      
    </div>

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/javascript/" rel="tag">#javascript</a>
          
            <a href="/tags/秘密花园/" rel="tag">#秘密花园</a>
          
        </div>
      

      
        <div class="post-nav">
          <div class="post-nav-prev post-nav-item">
            
          </div>

          <div class="post-nav-next post-nav-item">
            
              <a href="/2015/09/01/jqueryon/" rel="next">jQuery on()方法绑定多个选择器,多个事件</a>
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
    </div>
  </div>

 </div>

        

        
          <div class="comments" id="comments">
            
              <div class="ds-thread" data-thread-key="2015/09/01/javascriptsecret/"
                   data-title="Javascript 秘密花园" data-url="http://yoursite.com/2015/09/01/javascriptsecret/">
              </div>
            
          </div>
        
      </div>

      
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" src="/images/avatar.jpg" alt="Petitspois" itemprop="image"/>
          <p class="site-author-name" itemprop="name">Petitspois</p>
        </div>
        <p class="site-description motion-element" itemprop="description">前端开发,javascript,css3,html5,微信,博客</p>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">11</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          <div class="site-state-item site-state-categories">
            
              <span class="site-state-item-count">0</span>
              <span class="site-state-item-name">分类</span>
              
          </div>

          <div class="site-state-item site-state-tags">
            <a href="/tags">
              <span class="site-state-item-count">21</span>
              <span class="site-state-item-name">标签</span>
              </a>
          </div>

        </nav>

        
          <div class="feed-link motion-element">
            <a href="/atom.xml" rel="alternate">
              <i class="menu-item-icon icon-next-feed"></i>
              RSS
            </a>
          </div>
        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/petitspois" target="_blank">github</a>
              </span>
            
              <span class="links-of-author-item">
                <a href="http://weibo.com/2882105185" target="_blank">weibo</a>
              </span>
            
          
        </div>

        
        

        <div class="links-of-author motion-element">
          
        </div>

      </section>

      
        <section class="post-toc-wrap sidebar-panel-active">
          <div class="post-toc-indicator-top post-toc-indicator"></div>
          <div class="post-toc">
            
            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#对象"><span class="nav-number">1.</span> <span class="nav-text">对象</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#对象使用和属性"><span class="nav-number">1.1.</span> <span class="nav-text">对象使用和属性</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#对象作为数据类型"><span class="nav-number">1.1.1.</span> <span class="nav-text">对象作为数据类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#访问属性"><span class="nav-number">1.1.2.</span> <span class="nav-text">访问属性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#删除属性"><span class="nav-number">1.1.3.</span> <span class="nav-text">删除属性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#属性名的语法"><span class="nav-number">1.1.4.</span> <span class="nav-text">属性名的语法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#原型"><span class="nav-number">1.2.</span> <span class="nav-text">原型</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#属性查找"><span class="nav-number">1.2.1.</span> <span class="nav-text">属性查找</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#原型属性"><span class="nav-number">1.2.2.</span> <span class="nav-text">原型属性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#性能"><span class="nav-number">1.2.3.</span> <span class="nav-text">性能</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#扩展内置类型的原型"><span class="nav-number">1.2.4.</span> <span class="nav-text">扩展内置类型的原型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#总结"><span class="nav-number">1.2.5.</span> <span class="nav-text">总结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#hasOwnProperty_函数"><span class="nav-number">1.3.</span> <span class="nav-text">hasOwnProperty 函数</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#hasOwnProperty_作为属性"><span class="nav-number">1.3.1.</span> <span class="nav-text">hasOwnProperty 作为属性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#结论"><span class="nav-number">1.3.2.</span> <span class="nav-text">结论</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#for_in_循环"><span class="nav-number">1.4.</span> <span class="nav-text">for in 循环</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#使用_hasOwnProperty_过滤"><span class="nav-number">1.4.1.</span> <span class="nav-text">使用 hasOwnProperty 过滤</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#总结-1"><span class="nav-number">1.4.2.</span> <span class="nav-text">总结</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#函数_f(x)"><span class="nav-number">2.</span> <span class="nav-text">函数 f(x)</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#函数声明与表达式"><span class="nav-number">2.1.</span> <span class="nav-text">函数声明与表达式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#函数声明"><span class="nav-number">2.1.1.</span> <span class="nav-text">函数声明</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#函数赋值表达式"><span class="nav-number">2.1.2.</span> <span class="nav-text">函数赋值表达式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#命名函数的赋值表达式"><span class="nav-number">2.1.3.</span> <span class="nav-text">命名函数的赋值表达式</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#this_的工作原理"><span class="nav-number">2.2.</span> <span class="nav-text">this 的工作原理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#全局范围内"><span class="nav-number">2.2.1.</span> <span class="nav-text">全局范围内</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#函数调用"><span class="nav-number">2.2.2.</span> <span class="nav-text">函数调用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#方法调用"><span class="nav-number">2.2.3.</span> <span class="nav-text">方法调用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#调用构造函数"><span class="nav-number">2.2.4.</span> <span class="nav-text">调用构造函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#显式的设置_this"><span class="nav-number">2.2.5.</span> <span class="nav-text">显式的设置 this</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#常见误解"><span class="nav-number">2.2.6.</span> <span class="nav-text">常见误解</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#方法的赋值表达式"><span class="nav-number">2.2.7.</span> <span class="nav-text">方法的赋值表达式</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#闭包和引用"><span class="nav-number">2.3.</span> <span class="nav-text">闭包和引用</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#模拟私有变量"><span class="nav-number">2.3.1.</span> <span class="nav-text">模拟私有变量</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#为什么不可以在外部访问私有变量"><span class="nav-number">2.3.2.</span> <span class="nav-text">为什么不可以在外部访问私有变量</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#循环中的闭包"><span class="nav-number">2.3.3.</span> <span class="nav-text">循环中的闭包</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#避免引用错误"><span class="nav-number">2.3.4.</span> <span class="nav-text">避免引用错误</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#arguments_对象"><span class="nav-number">2.4.</span> <span class="nav-text">arguments 对象</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#转化为数组"><span class="nav-number">2.4.1.</span> <span class="nav-text">转化为数组</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#传递参数"><span class="nav-number">2.4.2.</span> <span class="nav-text">传递参数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#自动更新"><span class="nav-number">2.4.3.</span> <span class="nav-text">自动更新</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#性能真相"><span class="nav-number">2.4.4.</span> <span class="nav-text">性能真相</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#构造函数"><span class="nav-number">2.5.</span> <span class="nav-text">构造函数</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#工厂模式"><span class="nav-number">2.5.1.</span> <span class="nav-text">工厂模式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#通过工厂模式创建新对象"><span class="nav-number">2.5.2.</span> <span class="nav-text">通过工厂模式创建新对象</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#总结-2"><span class="nav-number">2.5.3.</span> <span class="nav-text">总结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#作用域与命名空间"><span class="nav-number">2.6.</span> <span class="nav-text">作用域与命名空间</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#隐式的全局变量"><span class="nav-number">2.6.1.</span> <span class="nav-text">隐式的全局变量</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#局部变量"><span class="nav-number">2.6.2.</span> <span class="nav-text">局部变量</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#变量声明提升（Hoisting）"><span class="nav-number">2.6.3.</span> <span class="nav-text">变量声明提升（Hoisting）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#名称解析顺序"><span class="nav-number">2.6.4.</span> <span class="nav-text">名称解析顺序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#命名空间"><span class="nav-number">2.6.5.</span> <span class="nav-text">命名空间</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#结论-1"><span class="nav-number">2.6.6.</span> <span class="nav-text">结论</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#数组"><span class="nav-number">3.</span> <span class="nav-text">数组</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#数组遍历与属性"><span class="nav-number">3.1.</span> <span class="nav-text">数组遍历与属性</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#遍历"><span class="nav-number">3.1.1.</span> <span class="nav-text">遍历</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#length_属性"><span class="nav-number">3.1.2.</span> <span class="nav-text">length 属性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#结论-2"><span class="nav-number">3.1.3.</span> <span class="nav-text">结论</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Array_构造函数"><span class="nav-number">3.2.</span> <span class="nav-text">Array 构造函数</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#结论-3"><span class="nav-number">3.2.1.</span> <span class="nav-text">结论</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#类型"><span class="nav-number">4.</span> <span class="nav-text">类型</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#相等与比较"><span class="nav-number">4.1.</span> <span class="nav-text">相等与比较</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#等于操作符"><span class="nav-number">4.1.1.</span> <span class="nav-text">等于操作符</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#严格等于操作符"><span class="nav-number">4.1.2.</span> <span class="nav-text">严格等于操作符</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#比较对象"><span class="nav-number">4.1.3.</span> <span class="nav-text">比较对象</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#结论-4"><span class="nav-number">4.1.4.</span> <span class="nav-text">结论</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#typeof_操作符"><span class="nav-number">4.2.</span> <span class="nav-text">typeof 操作符</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#JavaScript_类型表格"><span class="nav-number">4.2.1.</span> <span class="nav-text">JavaScript 类型表格</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#对象的类定义"><span class="nav-number">4.2.2.</span> <span class="nav-text">对象的类定义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#测试为定义变量"><span class="nav-number">4.2.3.</span> <span class="nav-text">测试为定义变量</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#结论-5"><span class="nav-number">4.2.4.</span> <span class="nav-text">结论</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#instanceof_操作符"><span class="nav-number">4.3.</span> <span class="nav-text">instanceof 操作符</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#比较自定义对象"><span class="nav-number">4.3.1.</span> <span class="nav-text">比较自定义对象</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#instanceof_比较内置类型"><span class="nav-number">4.3.2.</span> <span class="nav-text">instanceof 比较内置类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#结论-6"><span class="nav-number">4.3.3.</span> <span class="nav-text">结论</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#类型转换"><span class="nav-number">4.4.</span> <span class="nav-text">类型转换</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#内置类型的构造函数"><span class="nav-number">4.4.1.</span> <span class="nav-text">内置类型的构造函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#转换为字符串"><span class="nav-number">4.4.2.</span> <span class="nav-text">转换为字符串</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#转换为数字"><span class="nav-number">4.4.3.</span> <span class="nav-text">转换为数字</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#转换为布尔型"><span class="nav-number">4.4.4.</span> <span class="nav-text">转换为布尔型</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#核心"><span class="nav-number">5.</span> <span class="nav-text">核心</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#为什么不要使用_eval"><span class="nav-number">5.1.</span> <span class="nav-text">为什么不要使用 eval</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#伪装的_eval"><span class="nav-number">5.1.1.</span> <span class="nav-text">伪装的 eval</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#安全问题"><span class="nav-number">5.1.2.</span> <span class="nav-text">安全问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#结论-7"><span class="nav-number">5.1.3.</span> <span class="nav-text">结论</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#undefined_和_null"><span class="nav-number">5.2.</span> <span class="nav-text">undefined 和 null</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#处理_undefined_值的改变"><span class="nav-number">5.2.1.</span> <span class="nav-text">处理 undefined 值的改变</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#null_的用处"><span class="nav-number">5.2.2.</span> <span class="nav-text">null 的用处</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#自动分号插入"><span class="nav-number">5.3.</span> <span class="nav-text">自动分号插入</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#工作原理"><span class="nav-number">5.3.1.</span> <span class="nav-text">工作原理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#前置括号"><span class="nav-number">5.3.2.</span> <span class="nav-text">前置括号</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#结论-8"><span class="nav-number">5.3.3.</span> <span class="nav-text">结论</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#其它"><span class="nav-number">6.</span> <span class="nav-text">其它</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#setTimeout_和_setInterval"><span class="nav-number">6.1.</span> <span class="nav-text">setTimeout 和 setInterval</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#setInterval_的堆调用"><span class="nav-number">6.1.1.</span> <span class="nav-text">setInterval 的堆调用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#处理可能的阻塞调用"><span class="nav-number">6.1.2.</span> <span class="nav-text">处理可能的阻塞调用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#手工清空定时器"><span class="nav-number">6.1.3.</span> <span class="nav-text">手工清空定时器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#清除所有定时器"><span class="nav-number">6.1.4.</span> <span class="nav-text">清除所有定时器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#隐藏使用_eval"><span class="nav-number">6.1.5.</span> <span class="nav-text">隐藏使用 eval</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#结论-9"><span class="nav-number">6.1.6.</span> <span class="nav-text">结论</span></a></li></ol></li></ol></li></ol></div>
            
          </div>
          <div class="post-toc-indicator-bottom post-toc-indicator"></div>
        </section>
      

    </div>
  </aside>


    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner"> <div class="copyright" >
  
  &copy; &nbsp; 
  <span itemprop="copyrightYear">2015</span>
  <span class="with-love">
    <i class="icon-next-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Petitspois</span>
</div>

<div class="powered-by">
  由 <a class="theme-link" href="http://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Mist
  </a>
</div>


 </div>
    </footer>

    <div class="back-to-top"></div>
  </div>

  <script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>

  
  
  
    

  
    
  

  <script type="text/javascript">
    var duoshuoQuery = {short_name:"petitspois"};
    (function() {
      var ds = document.createElement('script');
      ds.type = 'text/javascript';ds.async = true;
      ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
      ds.charset = 'UTF-8';
      (document.getElementsByTagName('head')[0]
      || document.getElementsByTagName('body')[0]).appendChild(ds);
    })();
  </script>
    
     
  	<script src="/js/ua-parser.min.js"></script>
  	<script src="/js/hook-duoshuo.js"></script>
  

    
  
  
  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js"></script>
  <script type="text/javascript" src="/js/fancy-box.js?v=0.4.5.1"></script>


  <script type="text/javascript" src="/js/helpers.js?v=0.4.5.1"></script>
  

  <script type="text/javascript" src="/vendors/velocity/velocity.min.js"></script>
  <script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js"></script>

  <script type="text/javascript" src="/js/motion_global.js?v=0.4.5.1" id="motion.global"></script>




  <script type="text/javascript" src="/js/nav-toggle.js?v=0.4.5.1"></script>
  <script type="text/javascript" src="/vendors/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  
<script type="text/javascript" src="/js/bootstrap.scrollspy.js?v=0.4.5.1" id="bootstrap.scrollspy.custom"></script>


<script type="text/javascript" id="sidebar.toc.highlight">
  $(document).ready(function () {
    var tocSelector = '.post-toc';
    var $tocSelector = $(tocSelector);
    var activeCurrentSelector = '.active-current';

    $tocSelector
      .on('activate.bs.scrollspy', function () {
        var $currentActiveElement = $(tocSelector + ' .active').last();

        removeCurrentActiveClass();
        $currentActiveElement.addClass('active-current');

        $tocSelector[0].scrollTop = $currentActiveElement.position().top;
      })
      .on('clear.bs.scrollspy', function () {
        removeCurrentActiveClass();
      });

    function removeCurrentActiveClass () {
      $(tocSelector + ' ' + activeCurrentSelector)
        .removeClass(activeCurrentSelector.substring(1));
    }

    function processTOC () {
      getTOCMaxHeight();
      toggleTOCOverflowIndicators();
    }

    function getTOCMaxHeight () {
      var height = $('.sidebar').height() -
                   $tocSelector.position().top -
                   $('.post-toc-indicator-bottom').height();

      $tocSelector.css('height', height);

      return height;
    }

    function toggleTOCOverflowIndicators () {
      tocOverflowIndicator(
        '.post-toc-indicator-top',
        $tocSelector.scrollTop() > 0 ? 'show' : 'hide'
      );

      tocOverflowIndicator(
        '.post-toc-indicator-bottom',
        $tocSelector.scrollTop() >= $tocSelector.find('ol').height() - $tocSelector.height() ? 'hide' : 'show'
      )
    }

    $(document).on('sidebar.motion.complete', function () {
      processTOC();
    });

    $('body').scrollspy({ target: tocSelector });
    $(window).on('resize', function () {
      if ( $('.sidebar').hasClass('sidebar-active') ) {
        processTOC();
      }
    });

    onScroll($tocSelector);

    function onScroll (element) {
      element.on('mousewheel DOMMouseScroll', function (event) {
          var oe = event.originalEvent;
          var delta = oe.wheelDelta || -oe.detail;

          this.scrollTop += ( delta < 0 ? 1 : -1 ) * 30;
          event.preventDefault();

          toggleTOCOverflowIndicators();
      });
    }

    function tocOverflowIndicator (indicator, action) {
      var $indicator = $(indicator);
      var opacity = action === 'show' ? 0.4 : 0;
      $indicator.velocity ?
        $indicator.velocity('stop').velocity({
          opacity: opacity
        }, { duration: 100 }) :
        $indicator.stop().animate({
          opacity: opacity
        }, 100);
    }

  });
</script>

<script type="text/javascript" id="sidebar.nav">
  $(document).ready(function () {
    var html = $('html');
    var TAB_ANIMATE_DURATION = 200;
    var hasVelocity = $.isFunction(html.velocity);

    $('.sidebar-nav li').on('click', function () {
      var item = $(this);
      var activeTabClassName = 'sidebar-nav-active';
      var activePanelClassName = 'sidebar-panel-active';
      if (item.hasClass(activeTabClassName)) {
        return;
      }

      var currentTarget = $('.' + activePanelClassName);
      var target = $('.' + item.data('target'));

      hasVelocity ?
        currentTarget.velocity('transition.slideUpOut', TAB_ANIMATE_DURATION, function () {
          target
            .velocity('stop')
            .velocity('transition.slideDownIn', TAB_ANIMATE_DURATION)
            .addClass(activePanelClassName);
        }) :
        currentTarget.animate({ opacity: 0 }, TAB_ANIMATE_DURATION, function () {
          currentTarget.hide();
          target
            .stop()
            .css({'opacity': 0, 'display': 'block'})
            .animate({ opacity: 1 }, TAB_ANIMATE_DURATION, function () {
              currentTarget.removeClass(activePanelClassName);
              target.addClass(activePanelClassName);
            });
        });

      item.siblings().removeClass(activeTabClassName);
      item.addClass(activeTabClassName);
    });

    $('.post-toc a').on('click', function (e) {
      e.preventDefault();
      var targetSelector = escapeSelector(this.getAttribute('href'));
      var offset = $(targetSelector).offset().top;
      hasVelocity ?
        html.velocity('stop').velocity('scroll', {
          offset: offset  + 'px',
          mobileHA: false
        }) :
        $('html, body').stop().animate({
          scrollTop: offset
        }, 500);
    });

    // Expand sidebar on post detail page by default, when post has a toc.
    var $tocContent = $('.post-toc-content');
    if (isDesktop() && CONFIG.sidebar === 'post') {
      if ($tocContent.length > 0 && $tocContent.html().trim().length > 0) {
        displaySidebar();
      }
    }
  });
</script>



  <script type="text/javascript">
    $(document).ready(function () {
      if (CONFIG.sidebar === 'always') {
        displaySidebar();
      }
      if (isMobile()) {
        FastClick.attach(document.body);
      }
    });
  </script>

  

  
  

  
  <script type="text/javascript" src="/js/lazyload.js"></script>
  <script type="text/javascript">
    $(function () {
      $("#posts").find('img').lazyload({
        placeholder: "/images/loading.gif",
        effect: "fadeIn"
      });
    });
  </script>
</body>
</html>
